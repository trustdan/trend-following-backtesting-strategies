// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © danieltuckerrust
// ALTERNATIVE 44: ADX Pyramiding Hybrid
// THEORY: Combine Alt28's quality filtering (ADX >25) with Alt26's low-DD fractional exits
// - ENTRY: Only when ADX > 25 (strong trend confirmation) - avoid choppy markets
// - EXIT: Alt26's fractional pyramid (100%→75%→50%→25% at 3N, 6N, 9N, 12N)
// INSIGHT: Alt28 had legendary UNH 72% win rate but low trade count. Alt26 had low DDs.
// HYPOTHESIS: Quality entries + gradual profit-taking = best of both worlds
// Expected to improve: Commodities (avoid chop), Utilities (maybe make them tradeable?), ETFs (quality matters)

//@version=6
strategy("Seykota Alt 44: ADX Pyramid v1.0",
     overlay=true,
     initial_capital=100000,
     commission_type=strategy.commission.percent, commission_value=0.005,
     slippage=2,
     default_qty_type=strategy.fixed, default_qty_value=0,
     pyramiding=10,
     max_bars_back=5000)

allowLong = input.bool(true, "Allow LONGs?"), allowShort = input.bool(true, "Allow SHORTs?")
entryLen = input.int(55, "Donchian ENTRY", minval=10), nLen = input.int(20, "N = ATR length", minval=5)
stopN = input.float(2.0, "Initial stop (N)", minval=0.5, step=0.25)
trailLen = input.int(22, "Trail lookback", minval=5), trailN = input.float(3.0, "Trail (N)", minval=0.5, step=0.25)
addStepN = input.float(0.5, "Add every X*N", minval=0.25, step=0.25), maxUnits = input.int(4, "Max units", minval=1, maxval=10)
riskPct = input.float(1.0, "Risk % per unit", minval=0.1, maxval=5, step=0.1)

// ADX Filter (from Alt28)
useAdxFilter = input.bool(true, "Use ADX filter?")
adxLen = input.int(14, "ADX length", minval=5)
adxThresh = input.float(25.0, "ADX threshold", minval=10, step=5)  // Only enter when ADX > 25

// Fractional Pyramid Targets (from Alt26)
useFractional = input.bool(true, "Use fractional exits?")
t1N = input.float(3.0, "T1: Close 25% at (N)", minval=1, step=0.5)
t2N = input.float(6.0, "T2: Close 25% at (N)", minval=1, step=0.5)
t3N = input.float(9.0, "T3: Close 25% at (N)", minval=1, step=0.5)
t4N = input.float(12.0, "T4: Close 25% at (N)", minval=1, step=0.5)

useMarket = input.bool(false, "Use regime filter?"), marketSym = input.symbol("SPY", "Market symbol")
marketTF = input.timeframe("D", "Regime TF"), marketLen = input.int(200, "Market MA", minval=50)
minVol = input.int(0, "Min volume", minval=0), showSignals = input.bool(true, "Plot signals?"), plotDon = input.bool(true, "Plot Donchian?")
fromDate = input.time(defval=timestamp("2022-01-01T00:00:00"), title="FROM", confirm=true)
toDate = input.time(defval=timestamp("2099-12-31T23:59:59"), title="TO", confirm=true)
flatAtFrom = input.bool(true, "FLAT at range start?")
isRangeStart = (time[1] < fromDate) and (time >= fromDate)
if flatAtFrom and isRangeStart and strategy.position_size != 0
    strategy.close_all(comment="Flat at FROM")

sharesForUnit(_e, _n) =>
    r = _e * (riskPct/100.0)
    psr = math.max(stopN * _n, syminfo.mintick)
    math.max(1, math.floor(r / psr))

inRange = (time >= fromDate) and (time <= toDate)
N = ta.atr(nLen), volMA = ta.sma(volume, 20), liqOK = volMA >= minVol
donHi = ta.highest(high, entryLen), donLo = ta.lowest(low, entryLen)
donHiPrev = donHi[1], donLoPrev = donLo[1]
trailHighest = ta.highest(high, trailLen), trailLowest = ta.lowest(low, trailLen)

// ADX Calculation (standard Wilder method)
[diPlus, diMinus, adx] = ta.dmi(adxLen, adxLen)
adxOK = not useAdxFilter or (adx > adxThresh)  // Only trade when trend is strong

mClose = request.security(marketSym, marketTF, close), mMA = request.security(marketSym, marketTF, ta.sma(close, marketLen))
longRegOK = not useMarket or (mClose > mMA), shortRegOK = not useMarket or (mClose < mMA)
longBreak = allowLong and liqOK and longRegOK and adxOK and (close > donHiPrev)  // ADX FILTER ADDED
shortBreak = allowShort and liqOK and shortRegOK and adxOK and (close < donLoPrev)  // ADX FILTER ADDED

var float N_entry = na, var float entryPrice = na, var float lastAddLong = na, var float lastAddShort = na
var int units = 0, var bool t1 = false, var bool t2 = false, var bool t3 = false, var bool t4 = false
inPos = strategy.position_size != 0, inLong = strategy.position_size > 0, inShort = strategy.position_size < 0
if not inPos
    units := 0, lastAddLong := na, lastAddShort := na, N_entry := na, entryPrice := na
    t1 := false, t2 := false, t3 := false, t4 := false

if inRange and not inPos and longBreak
    N_entry := N, entryPrice := close
    strategy.entry("L", strategy.long, qty=sharesForUnit(strategy.equity, N_entry))
    units := 1, lastAddLong := close
if inRange and not inPos and shortBreak
    N_entry := N, entryPrice := close
    strategy.entry("S", strategy.short, qty=sharesForUnit(strategy.equity, N_entry))
    units := 1, lastAddShort := close

if inRange and inLong and units < maxUnits and high >= nz(lastAddLong) + addStepN * N_entry
    strategy.entry("L", strategy.long, qty=sharesForUnit(strategy.equity, N_entry)), units += 1, lastAddLong := close
if inRange and inShort and units < maxUnits and low <= nz(lastAddShort) - addStepN * N_entry
    strategy.entry("S", strategy.short, qty=sharesForUnit(strategy.equity, N_entry)), units += 1, lastAddShort := close

// FRACTIONAL PYRAMID EXITS (Alt26 style)
// Close 25% of position at each target: T1, T2, T3, T4 (4 exits to get to zero)
if useFractional and inLong and not na(entryPrice) and not na(N_entry)
    if not t1 and high >= entryPrice + t1N * N_entry
        strategy.close("L", qty=sharesForUnit(strategy.equity, N_entry), comment="T1-25%"), t1 := true
    if t1 and not t2 and high >= entryPrice + t2N * N_entry
        strategy.close("L", qty=sharesForUnit(strategy.equity, N_entry), comment="T2-25%"), t2 := true
    if t2 and not t3 and high >= entryPrice + t3N * N_entry
        strategy.close("L", qty=sharesForUnit(strategy.equity, N_entry), comment="T3-25%"), t3 := true
    if t3 and not t4 and high >= entryPrice + t4N * N_entry
        strategy.close("L", qty=sharesForUnit(strategy.equity, N_entry), comment="T4-25%"), t4 := true

if useFractional and inShort and not na(entryPrice) and not na(N_entry)
    if not t1 and low <= entryPrice - t1N * N_entry
        strategy.close("S", qty=sharesForUnit(strategy.equity, N_entry), comment="T1-25%"), t1 := true
    if t1 and not t2 and low <= entryPrice - t2N * N_entry
        strategy.close("S", qty=sharesForUnit(strategy.equity, N_entry), comment="T2-25%"), t2 := true
    if t2 and not t3 and low <= entryPrice - t3N * N_entry
        strategy.close("S", qty=sharesForUnit(strategy.equity, N_entry), comment="T3-25%"), t3 := true
    if t3 and not t4 and low <= entryPrice - t4N * N_entry
        strategy.close("S", qty=sharesForUnit(strategy.equity, N_entry), comment="T4-25%"), t4 := true

var float stopL = na, var float stopS = na
if inRange and inLong
    stopL := math.round_to_mintick(math.max(entryPrice - stopN * N_entry, trailHighest - trailN * N_entry))
    strategy.exit("L-EXIT", from_entry="L", stop=stopL)
else
    stopL := na
if inRange and inShort
    stopS := math.round_to_mintick(math.min(entryPrice + stopN * N_entry, trailLowest + trailN * N_entry))
    strategy.exit("S-EXIT", from_entry="S", stop=stopS)
else
    stopS := na

plot(plotDon ? donHi : na, "DonHi", color=color.new(color.blue, 40))
plot(plotDon ? donLo : na, "DonLo", color=color.new(color.blue, 40))
plotshape(showSignals and longBreak, title="L", style=shape.triangleup, location=location.belowbar, size=size.tiny, color=color.new(color.green, 0))
plotshape(showSignals and shortBreak, title="S", style=shape.triangledown, location=location.abovebar, size=size.tiny, color=color.new(color.red, 0))
// Color based on ADX: green = strong trend (>25), red = weak trend
adxColor = adx > adxThresh ? color.green : color.red
plot(showSignals and inLong ? stopL : na, "Stop", color=color.new(adxColor, 0), style=plot.style_linebr, linewidth=2)
plot(showSignals and inShort ? stopS : na, "Stop", color=color.new(adxColor, 0), style=plot.style_linebr, linewidth=2)
