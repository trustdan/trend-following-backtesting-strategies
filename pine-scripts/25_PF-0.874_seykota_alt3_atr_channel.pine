// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © danieltuckerrust
// ALTERNATIVE 3: ATR Channel Breakout
// THEORY: Volatility bands around a moving average define trends better than fixed lookback highs/lows.
// Rather than "highest high N days ago," define the breakout as price exceeding a volatility band
// above a base SMA. This is still pure price+volatility with fewer parameters and different mechanism.
// Trade-off: More responsive to volatility expansion/contraction.

//@version=6
strategy("Seykota Alt 3: ATR Channel v1.0",
     overlay=true,
     initial_capital=100000,
     commission_type=strategy.commission.percent, commission_value=0.005,
     slippage=2,
     default_qty_type=strategy.fixed, default_qty_value=0,
     pyramiding=10,
     max_bars_back=5000)

//================ Inputs
allowLong   = input.bool(true,  "Allow LONGs?")
allowShort  = input.bool(true,  "Allow SHORTs?")

// CHANGED: ATR Channel parameters instead of Donchian
baseLen     = input.int(100,    "Base MA length",                     minval=10)
nLen        = input.int(20,     "ATR length",                         minval=5)
kEntry      = input.float(2.0,  "Entry band (k * ATR)",               minval=0.25, step=0.25)
kExit       = input.float(2.0,  "Exit band (k * ATR)",                minval=0.25, step=0.25)
stopN       = input.float(2.0,  "Initial stop (in N)",                minval=0.25, step=0.25)
addStepN    = input.float(0.5,  "Add every X * N",                    minval=0.25, step=0.25)
maxUnits    = input.int(4,      "Max units",                          minval=1, maxval=10)
riskPct     = input.float(1.0,  "Risk % of equity PER UNIT",          minval=0.1, maxval=5, step=0.1)

useMarket   = input.bool(false, "Use market regime filter?")
marketSym   = input.symbol("SPY", "Market symbol for regime (if used)")
marketTF    = input.timeframe("D", "Regime timeframe (if used)")
marketLen   = input.int(200,    "Market MA length (if used)",         minval=50)

minVol      = input.int(0,      "Min 20-bar avg volume (chart TF)",   minval=0)
showSignals = input.bool(true,  "Plot signals & stops?")
plotBands   = input.bool(true,  "Plot ATR bands?")

// Date-range filter
fromDate = input.time(defval=timestamp("2022-01-01T00:00:00"), title="Backtest FROM (yyyy-mm-dd)", confirm=true)
toDate   = input.time(defval=timestamp("2099-12-31T23:59:59"), title="Backtest TO (yyyy-mm-dd)",   confirm=true)
flatAtFrom = input.bool(true, "Force FLAT at range start?")
isRangeStart = (time[1] < fromDate) and (time >= fromDate)
if flatAtFrom and isRangeStart and strategy.position_size != 0
    strategy.close_all(comment="Flat at FROM")

//================ Helpers
sharesForUnit(_equity, _Nentry) =>
    riskDollars   = _equity * (riskPct/100.0)
    perShareRisk  = math.max(stopN * _Nentry, syminfo.mintick)
    math.max(1, math.floor(riskDollars / perShareRisk))

inRange = (time >= fromDate) and (time <= toDate)

//================ Core calcs
base = ta.sma(close, baseLen)
N    = ta.atr(nLen)
volMA = ta.sma(volume, 20)
liqOK = volMA >= minVol

// CHANGED: ATR bands instead of Donchian levels
upBand   = base + kEntry * N
downBand = base - kEntry * N
exitUp   = base + kExit * N
exitDn   = base - kExit * N

// Use [1] to avoid lookahead
upBandPrev   = upBand[1]
downBandPrev = downBand[1]
exitUpPrev   = exitUp[1]
exitDnPrev   = exitDn[1]

// Market regime (optional)
mClose = request.security(marketSym, marketTF, close)
mMA    = request.security(marketSym, marketTF, ta.sma(close, marketLen))
longRegOK  = not useMarket or (mClose > mMA)
shortRegOK = not useMarket or (mClose < mMA)

//================ Signals (channel breakout)
longBreak  = allowLong  and liqOK and longRegOK  and (close > upBandPrev)
shortBreak = allowShort and liqOK and shortRegOK and (close < downBandPrev)

//================ Position state
var float N_entry       = na
var float lastAddLong   = na
var float lastAddShort  = na
var int   units         = 0

inPos     = strategy.position_size != 0
inLong    = strategy.position_size > 0
inShort   = strategy.position_size < 0

if not inPos
    units        := 0
    lastAddLong  := na
    lastAddShort := na
    N_entry      := na

//================ Entries
if inRange and not inPos and longBreak
    N_entry := N
    float sh = sharesForUnit(strategy.equity, N_entry)
    strategy.entry("L", strategy.long, qty=sh)
    units       := 1
    lastAddLong := close

if inRange and not inPos and shortBreak
    N_entry := N
    float sh = sharesForUnit(strategy.equity, N_entry)
    strategy.entry("S", strategy.short, qty=sh)
    units        := 1
    lastAddShort := close

//================ Add-ons
canAddLong  = inRange and inLong  and units < maxUnits and high >= nz(lastAddLong)  + addStepN * N_entry
canAddShort = inRange and inShort and units < maxUnits and low  <= nz(lastAddShort) - addStepN * N_entry

if canAddLong
    float sh = sharesForUnit(strategy.equity, N_entry)
    strategy.entry("L", strategy.long, qty=sh)
    units       += 1
    lastAddLong := close

if canAddShort
    float sh = sharesForUnit(strategy.equity, N_entry)
    strategy.entry("S", strategy.short, qty=sh)
    units        += 1
    lastAddShort := close

//================ Exits (ATR channel + protective stop)
var float stopL = na
var float stopS = na

if inRange and inLong
    initStopL = strategy.position_avg_price - stopN * N_entry
    // Exit if price crosses back through exit band OR hits initial stop
    stopL     := math.round_to_mintick(math.max(initStopL, exitDnPrev))
    strategy.exit("L-EXIT", from_entry="L", stop=stopL)
else
    stopL := na

if inRange and inShort
    initStopS = strategy.position_avg_price + stopN * N_entry
    // Exit if price crosses back through exit band OR hits initial stop
    stopS     := math.round_to_mintick(math.min(initStopS, exitUpPrev))
    strategy.exit("S-EXIT", from_entry="S", stop=stopS)
else
    stopS := na

//================ Plots
plot(plotBands ? base : na, "Base MA", color=color.new(color.gray, 0), linewidth=2)
plot(plotBands ? upBand : na,   "Upper Band", color=color.new(color.blue, 40), linewidth=1)
plot(plotBands ? downBand : na, "Lower Band", color=color.new(color.blue, 40), linewidth=1)
plot(plotBands ? exitUp : na,   "Exit Upper", color=color.new(color.red, 60), linewidth=1, style=plot.style_circles)
plot(plotBands ? exitDn : na,   "Exit Lower", color=color.new(color.red, 60), linewidth=1, style=plot.style_circles)

// Fill between bands
upFill = plotBands ? upBand : na
dnFill = plotBands ? downBand : na
fill(plot(upFill, display=display.none), plot(dnFill, display=display.none), color=color.new(color.blue, 95))

plotshape(showSignals and longBreak,  title="Long Breakout",  style=shape.triangleup,   location=location.belowbar, size=size.tiny, color=color.new(color.green, 0), text="ATR↑")
plotshape(showSignals and shortBreak, title="Short Breakout", style=shape.triangledown, location=location.abovebar, size=size.tiny, color=color.new(color.red,   0), text="ATR↓")

plot(showSignals and inLong  ? stopL : na, "Long Stop",  color=color.new(color.red, 0), style=plot.style_linebr, linewidth=2)
plot(showSignals and inShort ? stopS : na, "Short Stop", color=color.new(color.red, 0), style=plot.style_linebr, linewidth=2)
