// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © danieltuckerrust
// ALTERNATIVE 4: Asymmetric Long/Short System
// THEORY: Markets have a natural long bias (especially equities). Longs and shorts should use
// different parameters. More aggressive on longs (tighter stops, more units), more conservative 
// on shorts (wider stops, fewer units). Seykota: "Win or lose, everybody gets what they want out 
// of the market." This system assumes you WANT long bias.

//@version=6
strategy("Seykota Alt 4: Asymmetric L/S v1.0",
     overlay=true,
     initial_capital=100000,
     commission_type=strategy.commission.percent, commission_value=0.005,
     default_qty_type=strategy.fixed, default_qty_value=0,
     pyramiding=10,
     max_bars_back=5000)

//================ Inputs
allowLong   = input.bool(true,  "Allow LONGs?")
allowShort  = input.bool(true,  "Allow SHORTs?")

// Separate parameters for LONG trades
longEntryLen  = input.int(40,   "LONG Donchian ENTRY",        minval=10)
longExitLen   = input.int(10,   "LONG Donchian EXIT",         minval=5)
longStopN     = input.float(1.5,"LONG initial stop (N)",      minval=0.5, step=0.25)
longAddStepN  = input.float(0.4,"LONG add every X * N",       minval=0.25, step=0.25)
longMaxUnits  = input.int(5,    "LONG max units",             minval=1, maxval=10)
longRiskPct   = input.float(1.2,"LONG risk % per unit",       minval=0.1, maxval=5, step=0.1)

// Separate parameters for SHORT trades
shortEntryLen = input.int(60,   "SHORT Donchian ENTRY",       minval=10)
shortExitLen  = input.int(15,   "SHORT Donchian EXIT",        minval=5)
shortStopN    = input.float(2.5,"SHORT initial stop (N)",     minval=0.5, step=0.25)
shortAddStepN = input.float(0.6,"SHORT add every X * N",      minval=0.25, step=0.25)
shortMaxUnits = input.int(3,    "SHORT max units",            minval=1, maxval=10)
shortRiskPct  = input.float(0.8,"SHORT risk % per unit",      minval=0.1, maxval=5, step=0.1)

nLen        = input.int(20,     "N = ATR length",             minval=5)

useMarket   = input.bool(false, "Use market regime filter?")
marketSym   = input.symbol("SPY", "Market symbol")
marketTF    = input.timeframe("D", "Regime timeframe")
marketLen   = input.int(200,    "Market MA length",           minval=50)

minVol      = input.int(0,      "Min 20-bar avg volume",      minval=0)
showSignals = input.bool(true,  "Plot signals & stops?")
plotDon     = input.bool(true,  "Plot Donchian bands?")

fromDate = input.time(defval=timestamp("2022-01-01T00:00:00"), title="Backtest FROM")
toDate   = input.time(defval=timestamp("2099-12-31T23:59:59"), title="Backtest TO")

//================ Helpers
sharesForLong(_equity, _Nentry) =>
    riskDollars   = _equity * (longRiskPct/100.0)
    perShareRisk  = math.max(longStopN * _Nentry, syminfo.mintick)
    math.max(1, math.floor(riskDollars / perShareRisk))

sharesForShort(_equity, _Nentry) =>
    riskDollars   = _equity * (shortRiskPct/100.0)
    perShareRisk  = math.max(shortStopN * _Nentry, syminfo.mintick)
    math.max(1, math.floor(riskDollars / perShareRisk))

inRange = (time >= fromDate) and (time <= toDate)
flatAtFrom = input.bool(true, "Force FLAT at range start?")
isRangeStart = (time[1] < fromDate) and (time >= fromDate)

if flatAtFrom and isRangeStart and strategy.position_size != 0
    strategy.close_all(comment="Flat at FROM")

//================ Core calcs
N        = ta.atr(nLen)
volMA    = ta.sma(volume, 20)
liqOK    = volMA >= minVol

// LONG Donchian levels
longDonHi    = ta.highest(high, longEntryLen)
longDonLo    = ta.lowest(low,  longEntryLen)
longDonHiPrev= longDonHi[1]

longExitLoPrev = ta.lowest(low, longExitLen)[1]

// SHORT Donchian levels
shortDonHi    = ta.highest(high, shortEntryLen)
shortDonLo    = ta.lowest(low,  shortEntryLen)
shortDonLoPrev= shortDonLo[1]

shortExitHiPrev = ta.highest(high, shortExitLen)[1]

// Market regime
mClose = request.security(marketSym, marketTF, close)
mMA    = request.security(marketSym, marketTF, ta.sma(close, marketLen))
longRegOK  = not useMarket or (mClose > mMA)
shortRegOK = not useMarket or (mClose < mMA)

//================ Signals (using separate channels)
longBreak  = allowLong  and liqOK and longRegOK  and (close > longDonHiPrev)
shortBreak = allowShort and liqOK and shortRegOK and (close < shortDonLoPrev)

//================ Position state
var float N_entry       = na
var float lastAddLong   = na
var float lastAddShort  = na
var int   units         = 0

inPos     = strategy.position_size != 0
inLong    = strategy.position_size > 0
inShort   = strategy.position_size < 0

if not inPos
    units        := 0
    lastAddLong  := na
    lastAddShort := na
    N_entry      := na

//================ LONG Entries
if inRange and not inPos and longBreak
    N_entry := N
    float sh = sharesForLong(strategy.equity, N_entry)
    strategy.entry("L", strategy.long, qty=sh)
    units       := 1
    lastAddLong := close

//================ SHORT Entries
if inRange and not inPos and shortBreak
    N_entry := N
    float sh = sharesForShort(strategy.equity, N_entry)
    strategy.entry("S", strategy.short, qty=sh)
    units        := 1
    lastAddShort := close

//================ LONG Add-ons
canAddLong = inRange and inLong and units < longMaxUnits and close >= nz(lastAddLong) + longAddStepN * N_entry

if canAddLong
    float sh = sharesForLong(strategy.equity, N_entry)
    strategy.entry("L", strategy.long, qty=sh)
    units       += 1
    lastAddLong := close

//================ SHORT Add-ons
canAddShort = inRange and inShort and units < shortMaxUnits and close <= nz(lastAddShort) - shortAddStepN * N_entry

if canAddShort
    float sh = sharesForShort(strategy.equity, N_entry)
    strategy.entry("S", strategy.short, qty=sh)
    units        += 1
    lastAddShort := close

//================ LONG Exits
var float stopL = na

if inRange and inLong
    initStopL = strategy.position_avg_price - longStopN * N_entry
    stopL     := math.max(initStopL, longExitLoPrev)
    strategy.exit("L-EXIT", from_entry="L", stop=stopL)
else
    stopL := na

//================ SHORT Exits
var float stopS = na

if inRange and inShort
    initStopS = strategy.position_avg_price + shortStopN * N_entry
    stopS     := math.min(initStopS, shortExitHiPrev)
    strategy.exit("S-EXIT", from_entry="S", stop=stopS)
else
    stopS := na

//================ Plots
float longDonHiPlot = plotDon ? longDonHi : na
float longDonLoPlot = plotDon ? longDonLo : na
float shortDonHiPlot = plotDon ? shortDonHi : na
float shortDonLoPlot = plotDon ? shortDonLo : na

plot(longDonHiPlot, "Long Don High", color=color.new(color.green, 60), linewidth=2)
plot(shortDonLoPlot, "Short Don Low", color=color.new(color.red, 60), linewidth=2)

// Only show the opposite channel faintly
plot(longDonLoPlot, "Long Don Low", color=color.new(color.green, 90), linewidth=1)
plot(shortDonHiPlot, "Short Don High", color=color.new(color.red, 90), linewidth=1)

plotshape(showSignals and longBreak,  title="Long",  style=shape.triangleup,   location=location.belowbar, size=size.small, color=color.green)
plotshape(showSignals and shortBreak, title="Short", style=shape.triangledown, location=location.abovebar, size=size.small, color=color.red)

plot(showSignals and inLong  ? stopL : na, "Long Stop",  color=color.red, linewidth=2, style=plot.style_linebr)
plot(showSignals and inShort ? stopS : na, "Short Stop", color=color.red, linewidth=2, style=plot.style_linebr)

// Info table comparing long vs short parameters
var table infoTable = table.new(position.top_right, 3, 6, border_width=1)
if barstate.islast and showSignals
    table.cell(infoTable, 0, 0, "Parameter", text_color=color.white, bgcolor=color.gray)
    table.cell(infoTable, 1, 0, "LONG", text_color=color.white, bgcolor=color.green)
    table.cell(infoTable, 2, 0, "SHORT", text_color=color.white, bgcolor=color.red)
    
    table.cell(infoTable, 0, 1, "Entry Len:", text_color=color.white, bgcolor=color.gray)
    table.cell(infoTable, 1, 1, str.tostring(longEntryLen), text_color=color.white, bgcolor=color.gray)
    table.cell(infoTable, 2, 1, str.tostring(shortEntryLen), text_color=color.white, bgcolor=color.gray)
    
    table.cell(infoTable, 0, 2, "Stop (N):", text_color=color.white, bgcolor=color.gray)
    table.cell(infoTable, 1, 2, str.tostring(longStopN, "#.#"), text_color=color.white, bgcolor=color.gray)
    table.cell(infoTable, 2, 2, str.tostring(shortStopN, "#.#"), text_color=color.white, bgcolor=color.gray)
    
    table.cell(infoTable, 0, 3, "Max Units:", text_color=color.white, bgcolor=color.gray)
    table.cell(infoTable, 1, 3, str.tostring(longMaxUnits), text_color=color.white, bgcolor=color.gray)
    table.cell(infoTable, 2, 3, str.tostring(shortMaxUnits), text_color=color.white, bgcolor=color.gray)
    
    table.cell(infoTable, 0, 4, "Risk %:", text_color=color.white, bgcolor=color.gray)
    table.cell(infoTable, 1, 4, str.tostring(longRiskPct, "#.#") + "%", text_color=color.white, bgcolor=color.gray)
    table.cell(infoTable, 2, 4, str.tostring(shortRiskPct, "#.#") + "%", text_color=color.white, bgcolor=color.gray)
    
    table.cell(infoTable, 0, 5, "Current:", text_color=color.white, bgcolor=color.gray)
    posType = inLong ? "LONG (" + str.tostring(units) + ")" : inShort ? "SHORT (" + str.tostring(units) + ")" : "FLAT"
    posColor = inLong ? color.green : inShort ? color.red : color.gray
    table.cell(infoTable, 1, 5, posType, text_color=color.white, bgcolor=posColor)
    table.cell(infoTable, 2, 5, "", text_color=color.white, bgcolor=color.gray)
